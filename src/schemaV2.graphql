#########################
### SCALARs
#########################

"Date field, serialized as the number of milliseconds since the Unix Epoch"
scalar Date

"An amount (of a currency) that can be negative (i.g. in a transaction)"
scalar SignedAmount

"(Positive) Satoshi amount (i.g. quiz earning)"
scalar SatAmount

scalar Username # V: pattern(regexp: "^[A-Za-z0-9_]+$") stringLength(min: 3, max: 50)
scalar Memo # V: stringLength(max: 1024)
scalar Phone # V: pattern(regexp: "^\\+[0-9]+$")
scalar Name # V: stringLength(min: 3, max: 50)
scalar OneTimeAuthCode # V: range(min: 100000, max: 999999)
scalar OnChainAddress # V: pattern(regexp: "^[A-Fa-f0-9]+$") (bc1 for mainnet, tb1)
scalar FeeReimbursementHash

"A Lightning invoice with the amount included - BOLT11"
scalar LnInvoice # pattern(regexp: "^ln[A-Za-z0-9]+$")
"A Lightning invoice that does not include an amount - BOLT11"
scalar LnNoAmountInvoice # BOLT 11 but without amount
scalar LnInvoiceHash # V: stringLength(min: 64, max: 64) pattern(regexp: "^[A-Fa-f0-9]+$")
"Invoice lookup token"
scalar LnInvoiceSecret

#########################
### ENUMs
#########################

# ?: Mixed vs currency types
enum Currency {
  USD
  BTC
}

enum TxDirection {
  SEND
  RECEIVE
}

enum AccountStatus {
  ACTIVE
  LOCKED
}

enum Language {
  EN_US
  ES_SV
}

enum AccountLevel {
  "We have the user's phone number"
  ONE
  "We have the user's ID"
  TWO
}

# ?: PaymentStatus
enum InvoiceReceiveStatus {
  PAID
  NOT_PAID
}

"The range for the X axis in the BTC price graph"
enum PriceGraphRange {
  ONE_DAY
  ONE_WEEK
  ONE_MONTH
  ONE_YEAR
  FIVE_YEARS
}

enum TxStatus {
  PENDING
  SUCCESS
  FAILURE # ?: Reason
}

#########################
### Interfaces
#########################

# ?: Account
interface BaseAccount {
  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
  limits: Limits!
  csvTransactions(walletId: ID!): String!
}

# ?: Transaction
interface BaseTransaction {
  id: ID!
  amount: TxAmount!
  convertedAmount: TxAmount!
  description: String!
  status: TxStatus!
  createdAt: Date!
}

#########################
### Unions
#########################

union Account = ConsumerAcount | MerchantAcount
union OnUsAddress = Username | OnChainAddress | LnInvoinceHash | FeeReimbursementHash
union Transaction = OnUsTransaction | LnTransaction | OnChainTransaction
union MobileVersions = AndroirdVersions | IosVersions

#########################
### Custom Types
#########################

interface BaseAccount {
  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
  limits: Limits!
  csvTransactions(walletId: ID!): String!
}

type User {
  id: ID!
  username: Username!
  phone: Phone!
  contacts: [Contact!]! # TODO: Connection
  language: Language!
  quizQuestions: [UserQuizQuestion!]!
  defaultAccount: Account!
  # accounts: [Account!]! # FuturePlanning
  createdAt: Date!
}

type ConsumerAccount implements BaseAccount {
  # users: [User!]! # FuturePlanning
  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
  csvTransactions(walletId: ID!): String!
}

type MerchantAccount implements BaseAccount {
  # user: [User!]! # FuturePlanning
  mapInfo: MapInfo!

  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
  csvTransactions(walletId: ID!): String!
}

# # FuturePlanning
# type CorporateAccount implements BaseAccount {
#   user: [User!]!
# }

type TxAmount {
  currency: Currency!
  "Negative when sending"
  amount: SignedAmount!
  fee: Int!
}

type Balance {
  currency: Currency!
  amount: Int!
}

# initialize (invoice) & execute (payment)

# ?: Using the same wallet (ex, Bitcoin Beach)
# ?: 1) Pay with username, 2) Pay with LN, 3) Pay OnChain
# ?: Fees are less
# ?: Do we need it? Enterprise..
type OnUsTransaction implements BaseTransaction {
  id: ID!
  direction: TxDirection!
  amount: TxAmount!
  convertedAmount: TxAmount!
  description: String!
  status: TxStatus!
  createdAt: Date!

  address: OnUsAddress!
}

# ?: UsernameTransaction

type OnChainTransaction implements BaseTransaction {
  id: ID!
  direction: TxDirection!
  amount: TxAmount!
  convertedAmount: TxAmount!
  description: String!
  status: TxStatus!
  createdAt: Date!

  addresses: [OnChainAddress!]!
}

type LnTransaction implements BaseTransaction {
  id: ID!
  direction: TxDirection!
  amount: TxAmount!
  convertedAmount: TxAmount!
  description: String!
  status: TxStatus!
  createdAt: Date!

  hash: LnInvoinceHash! # V: 256 bits (64 chars)
}

# type exchangeTransaction implements Transaction {
#   rate: ...
#   fee: ...
# }

# ?: Should we convert this to generic currency/currency ratio?
type Price {
  id: ID! # Currently a date
  date: Date!
  price: Float! # price of 1 sat in USD (currently)
}

type QuizQuestion {
  id: ID!
  "The earn reward for the app to display their associated amount"
  earnAmount: SatAmount!
}

type UserQuizQuestion {
  question: QuizQuestion!
  completed: Boolean!
}

# ?: Account? Multiple wallets
type Wallet {
  id: ID!
  balance: Balance!
  transactions: [Transaction!]! # Connection
}

type Contact {
  id: Username!
  name: String # name can be set by the user
  transactionsCount: Int!
}

type MapInfo {
  title: String!
  coordinates: Coordinates!
}

type AndroirdVersions {
  minSupported: Int!
  currentSupported: Int!
}

type IosVersions {
  minSupported: Int!
  currentSupported: Int!
}

type Coordinates {
  longitude: Float!
  latitude: Float!
}

type MapMarker {
  id: ID!
  username: Username
  mapInfo: MapInfo!
}

type Limits {
  accountOldEnoughForWithdrawal: Boolean! # ?: Misplaced? Not a limit. AccountWithdrawlStatus?
  currentMaxSend: Int! # ?: Ln | OnChain
  cucrrentMaxSendOnUs: Int!
}

#########################
### Root Query
#########################
type Query {
  me: User
  priceListForGraph(range: PriceGraphRange!): [Price!]
  quizQuestions: [QuizQuestion!]
  merchantMapMarkers: [MapMarker!] # TODO: Map focus Connection | X merchants here
  mobileVersions: MobileVersions
  usernameExists(username: Username!): Boolean # TODO: security concerns
  depositFeePercentage: Float # Static
  onChainTxFee(address: Address!, amount: SatAmount!): SatAmount # Dynamic

  # settings... # FuturePlanning
}

#########################
### Input and Payload types for mutations
#########################

type UserError {
  message: String! # ?: i18n?
  fields: [String!]! # where the error occurred
}

type LnInvoicePayload {
  errors: [UserError!]!
  lnInvoice: LnInvoice
}

type LnNoAmountInvoicePayload {
  errors: [UserError!]!
  lnInvoice: LnNoAmountInvoice
}

input UsernameInput {
  username: Username!
}

type OnChainAddressPayload {
  errors: [UserError!]!
  onChainAddress: OnChainAddress
}

type TxStatusPayload {
  errors: [UserError!]!
  status: TxStatus
}

type SatAmountPayload {
  errors: [UserError!]!
  amount: SatAmount
}

input PhoneInput {
  phone: Phone!
}

input LoginInput {
  phone: Phone!
  code: OneTimeAuthCode!
}

input LanguageUpdateInput {
  language: Language!
}

input UsernameUpdateInput {
  username: Username!
}

input ContactUpdateInput {
  username: Username!
  name: Name!
}

input DeviceNotificationTokenInput {
  deviceToken: String!
}

input OnChainPaymentInput {
  address: Address!
  amount: SatAmount!
  memo: Memo
}

type OnChainPaymentAllInput {
  address: Address!
  memo: Memo
}

type LnNoAmountInvoiceCreateInput {
  memo: Memo
}

type LnInvoiceCreateInput {
  amount: SatAmount!
  memo: Memo
}

type LnNoAmountInvoiceCreateForUserInput {
  recipient: Username!
  memo: Memo
}

type LnInvoiceCreateForUserInput {
  recipient: Username!
  amount: SatAmount!
  memo: Memo
}

type LnNoAmountInvoicePaymentInput {
  invoice: LnNoAmountInvoice!
  amount: SatAmount!
  memo: Memo
}

input LnInvoicePaymentInput {
  invoice: LnDefinedAmountInvoice!
  memo: Memo
}

input LnPushPaymentFeeProbeInput {
  destination: String!
  amount: SatAmount!
}

input LnNoAmountInvoiceFeeProbeInput {
  invoice: LnNoAmountInvoice!
}

type LnInvoiceFeeProbeInput {
  invoice: LnInvoice!
  amount: SatAmuont!
}

type UserPaymentInput {
  recipient: Username!
  amount: SatAmount!
  memo: Memo
}

type AuthTokenPayload {
  errors: [UserError!]!
  authToken: AuthToken
}

type AuthTokenPayload {
  errors: [UserError!]!
  quizQuestions: [UserQuizQuestion!]
}

type SuccessPayload {
  errors: [UserError!]!
  success: Boolean
}

input QuizQuestionUpdateCompletedInput {
  ids: [ID!]!
}

input LnInvoiceReceiveStatusInput {
  hash: LnInvoiceHash!
  secret: LnInvoiceSecret!
}

type LnInvoiceReceivePayload {
  errors: [UserError!]!
  status: InvoiceReceiveStatus!
}

#########################
### Root Mutation
#########################
type Mutation {
  ## User mutations ##
  userRequestPhoneCode(input: PhoneInput!): SuccessPayload!
  userLogin(input: LoginInput!): AuthTokenPayload!
  userQuizeQuestionsUpdateCompleted(
    input: QuizQuestionUpdateCompletedInput
  ): QuizQuestionsUpdateCompletedPayload!
  userLanguageUpdate(input: LanguageUpdateInput!): UserPayload!
  usernameUpdate(input: UsernameUpdateInput!): UserPayload!
  userContactUpdate(input: ContactUpdateInput!): SuccessPayload!

  ## Device mutations ##
  deviceNotificationTokenCreate(input: DeviceNotificationTokenInput!): SuccessPayload!

  ## onChain mutations ##
  onChainAddressCreate: OnChainAddressPayload! # always a mutation
  onChainAddressCurrent: OnChainAddressPayload! # mutation first time it's issued, then query
  onChainPaymentSend(input: OnChainPaymentInput!): TxStatusPayload!
  onChainPaymentSendAll(input: OnChainPaymentAllInput!): TxStatusPayload!

  ## lightning mutations ##
  lnNoAmountInvoiceCreate(input: LnNoAmountInvoiceCreateInput!): LnNoAmountInvoicePayload!
  lnInvoiceCreate(input: LnInvoiceCreateInput!): LnInvoicePayload!
  lnNoAmountInvoicePaymentSend(input: LnNoAmountInvoicePaymentInput!): TxStatusPayload!
  lnInvoicePaymentSend(input: LnInvoicePaymentInput!): TxStatusPayload!
  lnPushPaymentFeeProbe(intput: LnPushPaymentFeeProbeInput!): SatAmountPayload!
  lnNoAmountInvoiceFeeProbe(intput: LnNoAmountInvoiceFeeProbeInput!): SatAmountPayload!
  lnInvoiceFeeProbe(intput: LnInvoiceFeeProbeInput!): SatAmountPayload!

  ## mutations that do not require auth ##
  ## Recieve payment from anonymous source ##
  lnNoAmountInvoiceCreateForUser(
    input: LnNoAmountInvoiceCreateForUserInput!
  ): LnNoAmountInvoicePayload! # FINAL (lnpage)
  # No use case yet
  lnInvoiceCreateForUser(input: LnInvoiceCreateForUserInput): LnInvoicePayload!

  ## Ledger entry (not part of LN) ##
  usernamePaymentSend(input: UserPaymentInput!): TxStatusPayload! # direct
}

#########################
### Root Subscription
#########################

type Subscription {
  priceCurrent: Price!

  lnInvoiceReceiveStatus(input: LnInvoiceReceiveStatusInput!): LnInvoiceReceivePayload! # FINAL (lnpage)

  # # FuturePlanning
  # newTransactions() {
  #   transactions: [Transactions]!
  # }
}
